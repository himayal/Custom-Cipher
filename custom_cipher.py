# -*- coding: utf-8 -*-
"""Custom_Cipher.ipynb

Automatically generated by Colab.

Original file is located at
    https://colab.research.google.com/drive/1E7G4NxHsltYuVHQtBuslGGme9-Fb1s4z
"""

import math
from collections import Counter
from typing import List, Tuple

ALPHABET = "ABCDEFGHIJKLMNOPQRSTUVWXYZ"
CHAR_TO_NUM = {c: i for i, c in enumerate(ALPHABET)}
NUM_TO_CHAR = {i: c for i, c in enumerate(ALPHABET)}

def sanitize(text: str) -> str:
    """Uppercase and keep letters A-Z only (useful for frequency & crypto ops)."""
    return "".join(ch for ch in text.upper() if ch.isalpha())

def modinv(a: int, m: int = 26) -> int:
    """Return modular inverse of a mod m, or raise ValueError."""
    a = a % m
    for x in range(1, m):
        if (a * x) % m == 1:
            return x
    raise ValueError(f"No modular inverse for a={a} mod {m}")

def valid_affine_a_values() -> List[int]:
    """All 'a' values valid for affine (coprime with 26)."""
    return [a for a in range(1, 26) if math.gcd(a, 26) == 1]

#Affine cipher functions
def affine_encrypt_letters(text: str, a: int, b: int) -> str:
    """Encrypt letters-only text using Affine (expects A-Z only)."""
    out = []
    for ch in text:
        x = CHAR_TO_NUM[ch]  # text should be sanitized already
        y = (a * x + b) % 26
        out.append(NUM_TO_CHAR[y])
    return "".join(out)

def affine_decrypt_letters(cipher: str, a: int, b: int) -> str:
    """Decrypt letters-only Affine ciphertext."""
    a_inv = modinv(a, 26)
    out = []
    for ch in cipher:
        y = CHAR_TO_NUM[ch]
        x = (a_inv * (y - b)) % 26
        out.append(NUM_TO_CHAR[x])
    return "".join(out)

# Rail-Fence cipher functions (letters-only)
def rail_fence_encrypt_letters(text: str, rails: int) -> str:
    """Encrypt letters-only text with rail-fence (zig-zag)."""
    if rails <= 1 or rails >= len(text):
        return text
    fence = ['' for _ in range(rails)]
    rail = 0
    step = 1
    for ch in text:
        fence[rail] += ch
        rail += step
        if rail == 0 or rail == rails - 1:
            step *= -1
    return ''.join(fence)

def rail_fence_decrypt_letters(cipher: str, rails: int) -> str:
    """Decrypt rail-fence for letters-only text."""
    if rails <= 1 or rails >= len(cipher):
        return cipher
    # Determine length of each rail
    n = len(cipher)
    pattern = [None] * n
    rail = 0
    step = 1
    for i in range(n):
        pattern[i] = rail
        rail += step
        if rail == 0 or rail == rails - 1:
            step *= -1
    # Count how many characters in each rail
    counts = [0] * rails
    for r in pattern:
        counts[r] += 1
    # Slice cipher into parts for each rail
    parts = []
    idx = 0
    for c in counts:
        parts.append(cipher[idx:idx + c])
        idx += c
    # Reconstruct plaintext by walking pattern
    pointers = [0] * rails
    result_chars = []
    for r in pattern:
        result_chars.append(parts[r][pointers[r]])
        pointers[r] += 1
    return ''.join(result_chars)

# Combined encryption and run
def encrypt_affine_then_rail(plaintext: str, a: int, b: int, rails: int) -> str:
    """Sanitize -> Affine -> Rail-Fence. Returns letters-only ciphertext."""
    letters = sanitize(plaintext)
    stage1 = affine_encrypt_letters(letters, a, b)
    stage2 = rail_fence_encrypt_letters(stage1, rails)
    return stage2

# Example usage
plaintext = "Network security project - Affine plus Rail Fence!"
a, b = 5, 8   # choose valid a from valid_affine_a_values()
rails = 3

print("Plaintext (original):", plaintext)
ct = encrypt_affine_then_rail(plaintext, a, b, rails)
print("Ciphertext (letters-only):", ct)

# Combined decryption and run
def decrypt_rail_then_affine(cipher_letters: str, a: int, b: int, rails: int) -> str:
    """Rail-Fence decrypt -> Affine decrypt -> returns recovered letters-only plaintext."""
    stage1 = rail_fence_decrypt_letters(cipher_letters, rails)
    stage2 = affine_decrypt_letters(stage1, a, b)
    return stage2

# Decrypt the ciphertext produced earlier
recovered = decrypt_rail_then_affine(ct, a, b, rails)
print("Recovered letters-only plaintext:", recovered)
# If you want to re-insert spaces/punctuation you must store their positions before sanitizing.