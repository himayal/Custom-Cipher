# -*- coding: utf-8 -*-
"""Demo_Custom_Cipher.ipynb

Automatically generated by Colab.

Original file is located at
    https://colab.research.google.com/drive/1f4XPDaHf3hvzfRYT_boJVn7jM9p3QHH8
"""

# ============================================================
#   AFFINE + RAIL-FENCE CIPHER — CUSTOM HYBRID CIPHER SYSTEM
#   Cipher Order: Affine → Rail-Fence
#   Includes Encryption, Decryption, and Known Plaintext Attack
# ============================================================

import string

# -----------------------------------------------
# Utility functions
# -----------------------------------------------

def sanitize(text):
    """Convert text to uppercase and remove non-alphabetic characters."""
    return ''.join([ch.upper() for ch in text if ch.isalpha()])

def mod_inverse(a, m):
    """Find modular inverse of a under mod m (for decryption)."""
    for i in range(26):
        if (a * i) % m == 1:
            return i
    raise ValueError("No modular inverse found for 'a'")

# -----------------------------------------------
# Affine Cipher
# -----------------------------------------------

def affine_encrypt(text, a, b):
    encrypted = ''
    for ch in text:
        if ch.isalpha():
            x = ord(ch) - 65
            encrypted += chr(((a * x + b) % 26) + 65)
    return encrypted

def affine_decrypt(cipher, a, b):
    decrypted = ''
    a_inv = mod_inverse(a, 26)
    for ch in cipher:
        if ch.isalpha():
            y = ord(ch) - 65
            decrypted += chr(((a_inv * (y - b)) % 26) + 65)
    return decrypted

# -----------------------------------------------
# Rail-Fence Cipher
# -----------------------------------------------

def rail_fence_encrypt(text, rails):
    rail = ['' for _ in range(rails)]
    dir_down = False
    row = 0

    for ch in text:
        rail[row] += ch
        if row == 0 or row == rails - 1:
            dir_down = not dir_down
        row += 1 if dir_down else -1

    return ''.join(rail)

def rail_fence_decrypt(cipher, rails):
    rail = [['\n' for _ in range(len(cipher))] for _ in range(rails)]
    dir_down = None
    row, col = 0, 0

    for i in range(len(cipher)):
        if row == 0:
            dir_down = True
        if row == rails - 1:
            dir_down = False
        rail[row][col] = '*'
        col += 1
        row += 1 if dir_down else -1

    index = 0
    for i in range(rails):
        for j in range(len(cipher)):
            if (rail[i][j] == '*') and (index < len(cipher)):
                rail[i][j] = cipher[index]
                index += 1

    result = []
    row, col = 0, 0
    for i in range(len(cipher)):
        if row == 0:
            dir_down = True
        if row == rails - 1:
            dir_down = False
        if rail[row][col] != '\n':
            result.append(rail[row][col])
            col += 1
        row += 1 if dir_down else -1

    return ''.join(result)

# -----------------------------------------------
# Known Plaintext Attack
# -----------------------------------------------

def known_plaintext_attack(known_plain, cipher_text):
    """Simple attack: tries to recover affine parameters using known plaintext."""
    print("\n===== Known Plaintext Attack Simulation =====")
    known_plain = sanitize(known_plain)
    cipher_text = sanitize(cipher_text)

    possible_keys = []
    for a in [1,3,5,7,9,11,15,17,19,21,23,25]:
        for b in range(26):
            dec = affine_decrypt(cipher_text, a, b)
            if known_plain in dec:
                possible_keys.append((a,b))

    if possible_keys:
        print(f"Possible (a,b) keys found: {possible_keys}")
    else:
        print("No key match found with given known plaintext.")

# -----------------------------------------------
# Main Demo System
# -----------------------------------------------

def main():
    print("══════════════════════════════════════════════════════════╗")
    print("║              AFFINE + RAIL-FENCE CIPHER DEMO             ║")
    print("║             Hybrid Classical Encryption System           ║")
    print("╚══════════════════════════════════════════════════════════╝")

    while True:
        print("\nOptions:\n1. Encrypt a message\n2. Decrypt a message\n3. Known-Plaintext Attack\n4. Exit")
        choice = input("Select option (1-4): ")

        if choice == '1':
            plaintext = input("\nEnter plaintext: ")
            a = int(input("Enter 'a' value (1,3,5,7,9,11,15,17,19,21,23,25): "))
            b = int(input("Enter 'b' value (0-25): "))
            rails = int(input("Enter number of rails (2-10): "))

            sanitized = sanitize(plaintext)
            affine_out = affine_encrypt(sanitized, a, b)
            final_cipher = rail_fence_encrypt(affine_out, rails)

            print("\nStep                 Output")
            print("-"*60)
            print(f"{'Sanitized Text':<20}{sanitized:<40}")
            print(f"{'After Affine':<20}{affine_out:<40}")
            print(f"{'After Rail-Fence':<20}{final_cipher:<40}")
            print("-"*60)
            print(f"Final Ciphertext: {final_cipher}")

        elif choice == '2':
            cipher = input("\nEnter ciphertext: ")
            a = int(input("Enter 'a' value: "))
            b = int(input("Enter 'b' value: "))
            rails = int(input("Enter number of rails used: "))

            rail_dec = rail_fence_decrypt(cipher, rails)
            affine_dec = affine_decrypt(rail_dec, a, b)

            print("\nStep                 Output")
            print("-"*60)
            print(f"{'After Rail-Fence':<20}{rail_dec:<40}")
            print(f"{'After Affine':<20}{affine_dec:<40}")
            print("-"*60)
            print(f"Decrypted Plaintext: {affine_dec}")

        elif choice == '3':
            known = input("\nEnter known part of plaintext: ")
            cipher = input("Enter ciphertext: ")
            known_plaintext_attack(known, cipher)

        elif choice == '4':
            print("\nExiting demo...")
            break
        else:
            print("Invalid option! Try again.")

if __name__ == "__main__":
    main()