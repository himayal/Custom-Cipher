# -*- coding: utf-8 -*-
"""Attack_Custom_Cipher.ipynb

Automatically generated by Colab.

Original file is located at
    https://colab.research.google.com/drive/1jDNWSqQxXgid4sNQgF1UN41GKlVUvlAX
"""

# ============================================================
#   ATTACK_CUSTOM_CIPHER NOTEBOOK — KNOWN PLAINTEXT ATTACK
# ============================================================

import hashlib
import random
import time
from collections import Counter
from typing import Dict, List

# Predefined constants
AFFINE_COPRIME_A = [1,3,5,7,9,11,15,17,19,21,23,25]

# Utility: sanitize text
def sanitize_text(text: str) -> str:
    return ''.join([c for c in text.upper() if 'A' <= c <= 'Z'])

# -------- Affine Cipher --------

def mod_inverse(a: int, m: int = 26) -> int:
    for x in range(1, m):
        if (a * x) % m == 1:
            return x
    raise ValueError(f"No modular inverse for {a}")

def affine_decrypt_letters(ciphertext: str, a: int, b: int) -> str:
    a_inv = mod_inverse(a, 26)
    result = []
    for ch in ciphertext:
        c = ord(ch) - ord('A')
        p = (a_inv * (c - b)) % 26
        result.append(chr(p + ord('A')))
    return ''.join(result)

# -------- Rail-Fence Cipher --------

def rail_fence_decrypt_letters(cipher: str, rails: int) -> str:
    if rails <= 1 or rails >= len(cipher):
        return cipher
    n = len(cipher)
    pattern = [None] * n
    rail, step = 0, 1
    for i in range(n):
        pattern[i] = rail
        rail += step
        if rail == 0 or rail == rails - 1:
            step *= -1
    counts = [0] * rails
    for r in pattern:
        counts[r] += 1
    parts, idx = [], 0
    for c in counts:
        parts.append(cipher[idx:idx + c])
        idx += c
    pointers = [0] * rails
    result_chars = []
    for r in pattern:
        result_chars.append(parts[r][pointers[r]])
        pointers[r] += 1
    return ''.join(result_chars)

def known_plaintext_attack(ciphertext: str, known_plain: str, max_rails: int = 10) -> List[Dict]:
    """
    Brute-force all possible (a,b,r) combinations for Affine + Rail-Fence.
    Return matches where decrypted plaintext contains known_plain.
    """
    known = sanitize_text(known_plain)
    matches = []

    for r in range(2, max_rails + 1):
        after_rf = rail_fence_decrypt_letters(ciphertext, r)
        for a in AFFINE_COPRIME_A:
            for b in range(26):
                decrypted = affine_decrypt_letters(after_rf, a, b)
                if known in decrypted:
                    matches.append({'a': a, 'b': b, 'r': r, 'plaintext': decrypted})
    return matches

# Example values copied from your Demo_Custom_Cipher notebook
ciphertext = "ZJZBDAFKZVCUAKNECCAGJFFCIDFIVIU"
known_plain = "HELLO"  # assume attacker knows part of plaintext

print("=== Known Plaintext Attack Demo ===")
print(f"Ciphertext: {ciphertext}")
print(f"Known plaintext: {known_plain}")

start_time = time.time()
results = known_plaintext_attack(ciphertext, known_plain, max_rails=10)
elapsed = time.time() - start_time

print(f"\nKnown-plaintext attack completed in {elapsed:.3f}s")
if results:
    print(f"Matches found: {len(results)}\n")
    for m in results[:5]:  # show first 5 results
        print(f"  Match → a={m['a']}  b={m['b']}  r={m['r']}")
        print(f"  Decrypted Text (first 60 chars): {m['plaintext'][:60]}")
        print("------------------------------------------------------")
else:
    print("No matches found.")

start_time = time.time()
results = known_plaintext_attack(ciphertext, known_plain, max_rails=10)
elapsed = time.time() - start_time

print(f"\nKnown-plaintext attack completed in {elapsed:.3f}s")
if results:
    print(f"Matches found: {len(results)}\n")
    for m in results[:5]:  # show first 5 results
        print(f"  Match → a={m['a']}  b={m['b']}  r={m['r']}")
        print(f"  Decrypted Text (first 60 chars): {m['plaintext'][:60]}")
        print("------------------------------------------------------")
else:
    print("No matches found.")